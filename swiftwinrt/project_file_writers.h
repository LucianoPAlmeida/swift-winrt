#pragma once

namespace swiftwinrt
{
    static void write_root_cmake(std::map<std::string, std::vector<std::string_view>>& namespaces, settings_type const& settings)
    {
        writer w;
        w.write("add_subdirectory(CWinRT)\n");
        for (auto&& [module, _] : namespaces)
        {
            w.write("add_subdirectory(%)\n", module);
        }

        auto filename{ settings.output_folder };
        filename += "CMakeLists.txt";
        w.flush_to_file(filename);
    }

    static void write_cmake_lists(std::string_view const& module, std::set<std::string> const& depends)
    {
        writer w;
        w.c_mod = settings.test ? "C" + settings.support : "CWinRT";
        w.type_namespace = module;
        auto content = R"(
set(GENERATED_FILES_DIR ${CMAKE_CURRENT_SOURCE_DIR})
file(GLOB SWIFTWINRT_GENERATED_FILES ${GENERATED_FILES_DIR}/*)
%
add_library(% SHARED
  ${SWIFTWINRT_GENERATED_FILES}%
  )

install(TARGETS %
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION bin
  COMPONENT lib)

target_link_libraries(% PRIVATE
  %
  %)

target_include_directories(%
  INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
  PRIVATE ${CMAKE_CURRENT_BINARY_DIR})

target_include_directories(%
  INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
  PRIVATE ${GENERATED_FILES_DIR})

)";
        w.write(content,
            settings.support == module ? "file(GLOB SUPPORT_FILES ${GENERATED_FILES_DIR}/Support/*)" : "",
            module,
            settings.support == module ? "\n  ${SUPPORT_FILES}" : "",

            module,
            module,
            w.c_mod,
            bind_list("\n  ", depends),
            module,
            module);
        w.save_cmake();
    }

    // Write a package.swift file which includes the full enclosure of Swift modules being generated (including CWinRT) which are generated
    // by the project. This is useful for our test project, which just creates a single module.
    static void write_multimodule_package_swift(std::map<std::string, std::set<std::string>>& module_dependencies, settings_type const& settings)
    {
        writer w;
        auto package = R"(// swift-tools-version: 5.7

// WARNING: Generated by a tool. Do not hand-edit!

import PackageDescription

let package = Package(
  name: "WinRT",
  products: [
%
  ],
  targets: [
    .target(
       name: "CWinRT",
       exclude: [
         "CMakeLists.txt"
       ]
    ),
%
  ]
)
)";


        w.write(package,
            bind([&](writer& w) {
                separator s{ w, "\n" };
        for (auto&& [module, _] : module_dependencies)
        {
            s();
            w.write(R"(    .library(name: "%", type: .dynamic, targets: ["%"]),)", module, module);
        }}),
            bind([&](writer& w) {
            for (auto [module, dependencies] : module_dependencies)
            {
                w.write(R"(    .target(
      name: "%",
      dependencies: [
        "CWinRT",
%
      ],
      path: "swift/%",
      exclude: [
        "CMakeLists.txt"
      ]
    ),
)", module, bind([&](writer& w) {
                        separator s{ w, "\n" };
                for (auto&& ns : dependencies)
                {
                    s();
                    w.write(R"(      "%",)", ns);

                }}),
                    module);
            }}
        ));
        auto filename{ w.root_directory() };
        filename += "Package.swift";
        w.flush_to_file(filename);
    }

    static void write_singlemodule_package_swift(std::string_view const& module, std::set<std::string> const& depends)
    {

    }
}
