#pragma once

#include "type_writers.h"
namespace swiftwinrt
{
    inline void write_preamble(writer& w)
    {
        if (settings.license)
        {
            w.write(R"(// Swift/WinRT v%

// Copyright (c) The Browser Company. All rights reserved.

)", SWIFTWINRT_VERSION_STRING);
        }
        else
        {
            w.write(R"(// WARNING: Please don't edit this file. It was generated by Swift/WinRT v%

)", SWIFTWINRT_VERSION_STRING);
        }

        if (!w.type_namespace.empty() && !w.support.empty())
        {
            auto module = get_swift_module(w.type_namespace);
            if (!settings.test)
            {
                if (module != w.support)
                {
                    w.depends.emplace(w.support);
                }

                for (auto& import : w.depends)
                {
                    w.write("import %\n", import);
                }
            }
          
            w.write("import %\n", w.c_mod);
        }

        w.write("\n");
    }

    inline std::string get_swift_module(std::string_view const& ns)
    {
        std::string result;
        result.reserve(ns.length());
        auto index = ns.find_first_of('.');
        if (index == std::string_view::npos)
        {
            result = ns;
        }
        else
        {
            result = ns.substr(0, index);
            result.shrink_to_fit();
        }

        return result;
    }

    inline std::string get_swift_module(TypeDef const& type)
    {
        if (settings.test)
        {
            return settings.support;
        }
        return get_swift_module(type.TypeNamespace());
    }

    inline std::string get_swift_namespace(writer const& w, std::string_view const& ns)
    {
        std::string result;

        result.reserve(ns.length());
        // Don't write the full namespace if all types are going into a single module, because
        // types in Windows.* namespace are *not* in the `Windows` module
        if (!settings.test && get_swift_module(w.type_namespace) != get_swift_module(ns))
        {
            // not writing type name in current module, use a fully scoped
            // module name instead
            result = ns;
        }
        else
        {
            auto index = ns.find_first_of('.');
            if (index != std::string_view::npos)
            {
                // remove the root namespace and module name so there isn't a
                // duplicat name
                result = ns.substr(index + 1);
            }
            else
            {
                result = ns;
            }

            result.shrink_to_fit();
        }

        return result;
    }

    inline std::string get_swift_namespace(writer const& w, TypeDef const& type)
    {
        return get_swift_namespace(w, type.TypeNamespace());
    }

    inline std::string get_full_swift_type_name(writer const& w, TypeDef const& type)
    {
        std::string result = get_swift_namespace(w, type);
        if (!result.empty())
        {
            result += '.';
        }
        result += type.TypeName();
        return result;
    }
}